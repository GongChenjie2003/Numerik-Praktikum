#include <iostream>
#include <fstream>
#include <filesystem>
#include <string>
#include <sstream>
#include <vector>
using namespace std;
namespace fs = filesystem;

//OPTION 3


/*struct Face {
    vector<int> vertices;   // Indizes der Punkte
    int owner;              // Eigentümerzelle
    int neighbour;          // Nachbarzelle (falls vorhanden)
};

struct Cell {
    vector<int> faces;       // Indizes der zugehörigen Faces
    vector<double> center;   // Zellmittelpunkt (x, y, z)
    vector<double> velocity; // Geschwindigkeitsvektor (Ux, Uy, Uz)
};

struct costant {
    vector<vector<double>> points;  // Liste der Punkte (x, y, z)
    vector<Face> faces;             // Liste der Faces (Vertices, Owner, Neighbour)
    vector<Cell> cells;             // Liste der Zellen mit zugehörigen Daten
};
*/







// OPTION 2

/*struct Face {
    vector<int> vertices;   // Indizes der Punkte                           
    int owner;              // Eigentümerzelle
    int neighbour;          // Nachbarzelle
};

struct costant {
    vector<vector<double>> points;  // 3D-Koordinaten aller Punkte
    vector<Face> faces;             // Liste der Faces mit zusätzlichen Infos
}; 

*/


// OPTION 1 (unverändert)
/*struct costant {                                // struct faces wo einzelne sachen eingespeichert werdern, in einem verktor oder array gespeichert; jedes face hat eigenes struct



    vector<vector<double>> points;
    vector<vector<int>> faces;
    vector<int> owner;
    vector<int> neighbour;
};
*/

struct CU {
    vector<vector<double>> C;
    vector<vector<double>> U;
};


vector<vector<double>> readPoints(const fs::path& file_path) {      //Einlesen von Points
    ifstream file(file_path);                                       //öffnet die Datei
    if (!file.is_open()) {
        cerr << "Error: Cannot open file " << file_path << endl;
        return {};
    }

    vector<vector<double>> vectors;
    string line;
    int current_line = 1;
    int Anzahl;                                                 //Anzahl = die Anzahl der Daten 


    while (getline(file, line)) {
        if (current_line == 20) {
            Anzahl = stoi(line);                               //line hat jetzt die Datentyp von string.
            break;                                             //Mit stoi wird string zu int tranformiert.
        }
        ++current_line;
    }


    while (getline(file, line) && current_line <= 20 + Anzahl) {
        size_t start = line.find('(');
        size_t end = line.find(')');                               //sucht und löscht die Klamma
        if (start != string::npos && end != string::npos && end > start) {  //npos = nichts(keine Klamma ist gefunden)
            string numbers = line.substr(start + 1, end - start - 1);
            istringstream iss(numbers);                           //"iss" sucht die Zahlen
            vector<double> vec(3);                                //Points sind 3 dimensional
            if (iss >> vec[0] >> vec[1] >> vec[2]) {
                vectors.push_back(vec);
            }
        }
        ++current_line;
    }
    cout << file_path << " eingelesen." << endl;
    file.close();
    return vectors;
}

vector<vector<double>> readCundU(const fs::path& file_path) {      //Diese Funktion ist ähnlich wie read pointsw
    ifstream file(file_path);
    if (!file.is_open()) {
        cerr << "Error: Cannot open file " << file_path << endl;
        return {};
    }

    vector<vector<double>> vectors;
    string line;
    int current_line = 1;
    int Anzahl;


    while (getline(file, line)) {
        if (current_line == 22) {
            Anzahl = stoi(line);
            break;
        }
        ++current_line;
    }


    while (getline(file, line) && current_line <= 22 + Anzahl) {
        size_t start = line.find('(');
        size_t end = line.find(')');
        if (start != string::npos && end != string::npos && end > start) {
            string numbers = line.substr(start + 1, end - start - 1);
            istringstream iss(numbers);
            vector<double> vec(3);
            if (iss >> vec[0] >> vec[1] >> vec[2]) {
                vectors.push_back(vec);
            }
        }
        ++current_line;
    }
    cout << file_path << " eingelesen." << endl;
    file.close();
    return vectors;
}

vector<vector<int>> readFaces(const fs::path& file_path) {         //Einlesen von faces
    ifstream file(file_path);
    if (!file.is_open()) {
        cerr << "Error: Cannot open file " << file_path << endl;
        return {};
    }

    vector<vector<int>> vectors;                                  //Ein dynamisches Array
    string line;
    int current_line = 1;
    int Anzahl;


    while (getline(file, line)) {
        if (current_line == 20) {
            Anzahl = stoi(line);
            break;
        }
        ++current_line;
    }
    while (getline(file, line) && current_line <= 20 + Anzahl) {
        size_t start = line.find('(');
        size_t end = line.find(')');
        if (start != string::npos && end != string::npos && end > start) {
            string numbers = line.substr(start + 1, end - start - 1);
            istringstream iss(numbers);
            vector<int> vec(4);                                    //faces sind 4-dimensional
            if (iss >> vec[0] >> vec[1] >> vec[2] >> vec[3]) {
                vectors.push_back(vec);
            }
        }
        ++current_line;
    }
    cout << file_path << " eingelesen." << endl;
    file.close();
    return vectors;
}

vector<int> readOwner(const fs::path& file_path) {                  //Einlesen von owner
    ifstream file(file_path);
    if (!file.is_open()) {
        cerr << "Error: Cannot open file " << file_path << endl;
        return {};
    }

    vector<int> vectors;                                          //Owner ist 1-dimensional, deswegen nur einmal "vector<>"
    string line;
    int current_line = 1;
    int Anzahl;

    while (getline(file, line)) {
        if (current_line == 21) {
            Anzahl = stoi(line);
            break;
        }
        ++current_line;
    }


    while (getline(file, line) && current_line <= 21 + Anzahl) {
        istringstream iss(line);
        int value;
        if (iss >> value) {
            vectors.push_back(value);
        }
        ++current_line;
    }
    cout << file_path << " eingelesen." << endl;
    file.close();
    return vectors;
}

vector<int> readNeighbour(const fs::path& file_path) {                  //Einlesen von neighbour
    ifstream file(file_path);
    if (!file.is_open()) {
        cerr << "Error: Cannot open file " << file_path << endl;
        return {};
    }

    vector<int> vectors;                                          //Neighbour ist 1-dimensional, deswegen nur einmal "vector<>"
    string line;
    int current_line = 1;
    int Anzahl;

    while (getline(file, line)) {
        if (current_line == 21) {
            Anzahl = stoi(line);
            break;
        }
        ++current_line;
    }


    while (getline(file, line) && current_line <= 21 + Anzahl) {
        istringstream iss(line);
        int value;
        if (iss >> value) {
            vectors.push_back(value);
        }
        ++current_line;
    }
    cout << file_path << " eingelesen." << endl;
    file.close();
    return vectors;
}

fs::path findFileInDirectory(const fs::path& folder_path, const string& file_name) {   //sucht und öffnet die Datei mit Folderpath und Filename
    for (const auto& entry : fs::recursive_directory_iterator(folder_path)) {     //sucht rekursiv alle Logs     
        if (entry.is_regular_file() && entry.path().filename() == file_name) {
            return entry.path();
        }
    }
    cerr << "Error: File '" << file_name << "' not found in directory '" << folder_path << "'." << endl;
    return {};
}

void displayCell(const vector<vector<int>>& faces,
    const vector<int>& owner,
    const vector<vector<double>>& points, int ownerID) {
    vector<int> faceIndices;

    for (int i = 0; i < owner.size(); ++i) {       // sucht in Owner alle gleichen Zahlen
        if (owner[i] == ownerID) {
            faceIndices.push_back(i);
        }
    }

    if (faceIndices.empty()) {
        cout << "No faces found for owner ID: " << ownerID << endl;
        return;
    }

    cout << "Faces for owner ID " << ownerID << ":" << endl;
    for (int faceIndex : faceIndices) {                         //zeigt die 6 Faces von Owner
        cout << "Face " << faceIndex << ": ";
        for (int vertexIndex : faces[faceIndex]) {
            cout << vertexIndex << " ";
        }
        cout << endl;

        cout << "Points for Face " << faceIndex << ":" << endl; //zeigt die 4 Eckpunkte jedes Faces
        for (int vertexIndex : faces[faceIndex]) {
            if (vertexIndex >= 0 && vertexIndex < points.size()) {
                cout << "Point " << vertexIndex << ": ";
                for (double coord : points[vertexIndex]) {     // zeigt die Koordination der Punkten
                    cout << coord << " ";
                }
                cout << endl;
            }
            else {
                cerr << "Error: Point index " << vertexIndex << " is out of range." << endl;
            }
        }
        cout << endl;

    }
}

vector<string> Zeitpunktliste() {                      //Erstellen der Liste mit den Zeitpunkten 0 dann 0.2 usw...
    vector<string> Zeitpunkte;                         //Die Liste mit den Zahlen als string, den wir dann zum Hautpdateipfad hinzufügen können
    for (int i = 0; i <= 15; ++i) {                    //Iteriert i von 0 bis 15 in 1er Schritten. 0 -> 1 -> 2 -> 3 ...

        stringstream ss;                               //Ermöglicht uns hier einfach i in ein string umzuwandeln 
        if (i == 0) {                                  //          
            ss << 0;                                   //Für 0 statt 0.0
        }
        else {
            ss << i;
        }
        Zeitpunkte.push_back(ss.str());

        for (float j = 0.2; j < 1.0; j += 0.2) {       // Dezimalwerte (0.2, 0.4, ...)
            if (i == 15 && j > 0) {
                break;
            }
            stringstream ss2;
            ss2 << i + j;
            Zeitpunkte.push_back(ss2.str());           //push_back = packt bereits erstelltes Objekt ind Liste | emplace_back = erstellt Objekt direkt in der Liste
        }
    }

    return Zeitpunkte;                                  //gibt die Liste zurück
}

void loadZeitpunkte(const string& Hauptordner) {              //Funktion, um die einzelnen Dateipfade der Unterordner 0,0.2,0.4,...zu erstellen
    vector<string> Zeitpunkte = Zeitpunktliste();             //Erstellt mit der Funktion Zeitpunktliste die Liste der Zeitpunkte als strings

    for (const auto& Zeitpunkt : Zeitpunkte) {                 //Geht durch jeden Zeitpunkt, der Liste mit den Zeitpunkten
        string Ordner = Hauptordner + "\\" + Zeitpunkt;       //Macht aus "C:\\Simulation_Umstroemung_eines_Wuerfels" --> "C:\\Simulation_Umstroemung_eines_Wuerfels\\0"
    }
}

int main() {
    string folder_path_costant = ".\\Wuerfel\\constant\\polyMesh";
    string points_file_name = "points";
    string faces_file_name = "faces";
    string owner_file_name = "owner";
    string neighbour_file_name = "neighbour";
    string folder_path_CundU = ".\\Wuerfel\\0";
    string C_file_name = "C";
    string U_file_name = "U";

    fs::path points_file_path = findFileInDirectory(folder_path_costant, points_file_name);
    fs::path faces_file_path = findFileInDirectory(folder_path_costant, faces_file_name);
    fs::path owner_file_path = findFileInDirectory(folder_path_costant, owner_file_name);
    fs::path neighbour_file_path = findFileInDirectory(folder_path_costant, neighbour_file_name);


    if (points_file_path.empty() || faces_file_path.empty() || owner_file_path.empty()) {
        cerr << "Error: Could not find one or all files." << endl;
        return 1;
    }

    fs::path C_file_path = findFileInDirectory(folder_path_CundU, C_file_name);
    fs::path U_file_path = findFileInDirectory(folder_path_CundU, U_file_name);


    vector<vector<double>> points = readPoints(points_file_path);
    vector<vector<double>> C = readCundU(C_file_path);
    vector<vector<double>> U = readCundU(U_file_path);
    vector<vector<int>> faces = readFaces(faces_file_path);
    vector<int> owner = readOwner(owner_file_path);
    vector<int> neighbour = readNeighbour(neighbour_file_path);

    costant meshData;
    CU fieldData;

    meshData.points = readPoints(points_file_path);
    meshData.faces = readFaces(faces_file_path);
    meshData.owner = readOwner(owner_file_path);
    meshData.neighbour = readNeighbour(neighbour_file_path);

    fieldData.C = readCundU(C_file_path);
    fieldData.U = readCundU(U_file_path);

    if (points.empty() || faces.empty()) {
        cerr << "Error: Failed to load data from one or both files.\n";
        return 1;
    }

    int index;
    while (true) {
        cout << "Enter the number of cell to display (negative number to exit): ";
        cin >> index;
        if (index < 0) break;
        displayCell(faces, owner, points, index);
    }

    return 0;
}
